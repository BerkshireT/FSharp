<html>
<head>
<link rel="stylesheet" type="text/css" href="pl.css"/>
<title>Introduction to F#</title>
</head>

<body>

<table border="0" width="80%">
<tr>
<td>
   
<h1 align="center">Introduction to F#</h1>
<hr align="center" width="80%" size="10"/>

<b>Author:</b> Tyler Berkshire
<br><br>
<b>CPS 452:</b> Emerging Programming Languages, Fall 2019

<h2><hr align="left" width="40%"/>Brief History</h2>
<ul>

<li>Developed by F# Software Foundation, Microsoft, and open contributors</li>
<li>Member of the ML language family</li>
<li>Originally created by Don Syme from Microsoft Research in Cambridge, UK</li>
<li>Strong influences from C#, Python, Haskell, Scala, and Erlang</li>
<li>Created in 2005, large version updates yearly (currently 4.7 as of Sept. 2019)</li>


</ul>

<h2><hr align="left" width="40%"/>
Key language concepts in F#
<hr align="left" width="40%"/></h2>
<ul>

<li>Developed as a cross-platform Common Language Infrastructure (CLI) language</li>
   <ul>
      <li>The CLI is a standardized specification from Microsoft for use of languages on different platforms</li>
      <li>.NET Framework and .NET Core are examples of implementations of the CLI</li>
   </ul>
<li>Strongly typed (algebraic)</li>
<li>Multi-paradigm (Imperative, Object-Oriented, Functional) with an emphasis on Functional</li>
<li>Data is immutable</li>
<li>Functions are first-class</li>
<li>Pattern matching for control flow</li>
<li>Metaprogramming. F# is commonly used to generate:</li>
   <ul>
      <li>JavaScript code</li>
      <li>GPU code</li>
      <li>Other web framework code</li>
      <ul>
         <li>For example, in the WebSharper framework F# is executed as .NET code server-side and generates JavaScript for client-side</li>
      </ul>
   </ul>
<li>Eager evaluation with capability to lazily evaluate (yield)</li>
<li>Async workflows</li>
</ul>

<h2><hr align="left" width="40%"/>
Core F#
<hr align="left" width="40%"/></h2>
<ul>
<li><a href="#algebraic">Algebraic Types</a></li>
   <ul>
      <li>Defined from a combination of product and sum constructions</li>
      <li>Compound types are built by:</li>
      <ul>
         <li>A combination of values from a set of types (product)</li>
         <li>A disjoint union from a set of types (sum)</li>
      </ul>
      <li>Pattern Matching is useful for edge cases and error handling:</li>
      <ul>
         <li>Generic cases:</li>
         <pre>
match functionReturn with
   | Some returnValue -> printfn "We got a proper return of %A" returnValue
   | None -> printfn "We found an error case"
         </pre>
         <li>Specific cases:</li>
         <pre>
match list with
   | [] -> printfn "Empty list"                                     // empty list
   | [x] -> printfn "Only %A" x                                     // only one item in the list
   | x::y::tail -> printfn "First %A, Second %A, Tail %A" x y tail  // at least two items in the list
         </pre>
      </ul>
   </ul>
<li><a href="#meta">Metaprogramming</a></li>
   <ul>
      <li>Quotations allow the generation of Abstract Syntax Trees (ASTs) which represent F# code</li>
      <li>These ASTs can be used to generate F# code or code in some other language</li>
      <li>Quotations are not compiled as part of the program, but as object representing an expression</li>
   </ul>
<li><a href="#pcc">Piping, Composition, and Currying</a></li>
   <ul>
      <li>Piping is used for a sequence of operations (similar to UNIX)</li>
      <li>Composition calls two functions in a sequence and returns a new function (chaining)</li>
      <li>Currying creates a new function by applying 1 to N-1 args to a function of N args</li>
   </ul>
<li><a href="#acp">Asynchronous, Concurrent, and Parallel Programming</a></li>
   <ul>
      <li>Asynchronous workflows can be easily composed, scheduled and transformed with the <tt>Async</tt> module</li>
      <li>The actor model of concurrency is built in via <tt>MailboxProcessor</tt></li>
      <li>True CPU parallelism can be achieved using the .NET Task Parallel Library</li>
   </ul>
<li><a href="#misc">Miscellaneous Aspects</a></li>
</ul>

<h2 id="algebraic"><hr align="left" width="40%"/>
Algebraic Types
<hr align="left" width="40%"/></h2>
<ul>
<li>F# has a mixture of types:</li>
   <ul>
      <li>Common .NET types (int, bool, string...)</li>
      <li>F# specific types (Lists, Records, Discriminated Unions...)</li>
   </ul>
<li>Advantages to using F# specific types when creating new types:</li>
   <ul>
      <li>Immutable</li>
      <li>Cannot be null</li>
      <li>Built-in equality and comparison</li>
      <li>Built-in pretty printing</li>
   </ul>
<li>New types are constructed using sum and product operations</li>
<li>An infinite number of new types can be made using these two operations, i.e. Absract Data Types (ADT)</li>
<li>Types cannot be declared inside of functions, only in namespaces or modules</li>
<li>Simple (record) type example:</li>
<pre>
open System
type Person<'a> = { FirstName: string; LastName: string; Weight: 'a }                           // quote denotes generic type
let main() =
   let Tyler = { FirstName = "Tyler"; LastName = "Berkshire"; Weight = 145 }                    // construct
   let TylerB = { FirstName = "Tyler"; LastName = "Berkshire"; Weight = "145" }   
   printfn "%s\'s last name is %s and weighs %A" Tyler.FirstName Tyler.LastName Tyler.Weight    // deconstruct
   printfn "%s\'s last name is %s and weighs %A" TylerB.FirstName TylerB.LastName TylerB.Weight 
   let { Weight = 145.50 } = Tyler                                                              // error: cannot change generic once assigned
</pre>
<li>Simple (discriminated union) type example:</li>
<pre>
type Tree<'a> = Leaf | T of Tree<'a> * 'a * Tree<'a>
let main() = 
   let leaf1 = T(Leaf)
   let leaf2 = T(Leaf)
   let tree = T(leaf1, "Tyler", leaf2)
</pre>
<li>Lists can only be of the same type</li>
<pre>
let list1 = [ 1; 2; 3; 4; 5 ]                     // list construction
let list2 = [ 1 .. 5 ]                            // using ranges
let list3 = 20 :: list2                           // cons
let list4 = list3 @ [ 6; 7; 8 ]                   // append
let list5 = [ for x in 1 .. 10 do yield (x * x) ] // generator comprehension (with lazy eval)
</pre>
<li>Tuples can be of mixed types</li>
<pre>
let tuple1 = ("CPS", 452)        // type string * int
let tuple2 = (452, "CPS")        // int * string /= string * int
fst tuple1                       // "CPS"
snd tuple1                       // 452
let tuple3 = ("CPS", 452, true)  // cannot use fst or snd on non-pair tuples
tuple3.GetHashCode()             // tuples can be used as dictionary keys w/ automatically defined hash values
</pre>
</ul>

<h2 id="meta"><hr align="left" width="40%"/>
Metaprogramming
<hr align="left" width="40%"/></h2>
<ul>
<li><code>Microsoft.FSharp.Quotations</code> is the module used for quotations</li>
<li>Quotations can be created with and without type information</li>
<ul>
   <li>Use <code><@</code> and <code>@></code> to include type information</li>
   <pre>
let expr : Expr<'T> = <@ 1 + 1 @>   // 'T will be int in this case
   </pre>
   <li>Use <code><@@</code> and <code>@@></code> to not include type information</li>
   <pre>
let expr2 : Expr = <@@ 1 + 1 @@>    // The resulting Expr is the raw non-generic type
   </pre>
</ul>
<li>Traversing the AST is faster without type information</li>
<li>Quotations must include a complete expression i.e. the definition of the bound name and the expression which uses it</li>
<ul>
   <li>Valid</li>
   <pre>
<@ let f x = x + 10 in f 20 @>
<@ 
   let f x = x + 10
   f 20
@>
   </pre>
   <li>Not valid</li>
   <pre>
<@ let f x = x + 10 @>
   </pre>
</ul>
<li>Splicing allows for the combination of code quotations with expressions created programmatically or from other quotations</li>
<ul>
   <li>Use <code>%</code> and <code>%</code> to include type information</li>
   <pre>
<@ 1 + %expr @>
   </pre>
   <li>Use <code>%%</code> and <code>%%</code> to not include type information</li>
   <pre>
<@@ 1 + %%expr @@>
   </pre>
</ul>
<li>The F# equivalent of an <code>eval</code> statement is implemented by compiling F# code with the F# PowerPack API</li>
<li>Here's an example of using quotations which translates simple F# code into expression objects and then prints back the F# code representation:</li>
<pre>
open System
open Microsoft.FSharp.Quotations.Patterns
open Microsoft.FSharp.Quotations.DerivedPatterns

let printQ expr =
   let rec print expr =
      match expr with
      | Application(expr1, expr2) -> // Function application
         print expr1
         printf " "
         print expr2
      | SpecificCall <@@ (+) @@> (_, _, exprList) -> // Matches a call to +
         print exprList.Head
         printf " + "
         print exprList.Tail.Head
      | Call(_, methodInfo, exprList) ->
         printf "%s.%s(" methodInfo.DeclaringType.Name methodInfo.Name
         if (exprList.IsEmpty) then printf ")" else
         print exprList.Head
         for expr in exprList.Tail do
            printf ","
            print expr
         printf ")"
      | Int32(n) ->
         printf "%d" n
      | Lambda(param, body) -> // Lambda expression
         printf "fun (%s:%s) -> " param.Name (param.Type.ToString())
         print body
      | Let(var, expr1, expr2) -> // Let binding
         if (var.IsMutable) then
            printf "let mutable %s = " var.Name
         else
            printf "let %s = " var.Name
         print expr1
         printf " in "
         print expr2
      | PropertyGet(_, propOrValInfo, _) ->
         printf "%s" propOrValInfo.Name
      | String(str) ->
         printf "%s" str
      | Value(value, typ) ->
         printf "%s" (value.ToString())
      | Var(var) ->
         printf "%s" var.Name
      | _ -> printf "%s" (expr.ToString())
   print expr
   printfn ""

let a = 2
let exprLambda = <@ fun x -> x + 1 @>    // type (int -> int)
let exprCall = <@ a + 1 @>               // type unit
let exprUnimplemented = <@ a - 1 @>
                                         // output:
printQ exprLambda                        // fun (x:System.Int32) -> x + 1
printQ exprCall                          // a + 1
printQ exprUnimplemented                 // Operators.op_Subtraction(a,1)
printQ <@@ let f x = x + 10 in f 10 @@>  // let f = fun (x:System.Int32) -> x + 10 in f 10
</pre>
</ul>

<h2 id="pcc"><hr align="left" width="40%"/>
Piping, Composition, and Currying
<hr align="left" width="40%"/></h2>
<ul>
<li>Piping</li>
<ul>
   <li>Used to perform a sequence of operations on some value</li>
   <li>Similar to UNIX, the output of each function becomes the input for the next</li>
   <li><code>\></code> is the symbol for a pipe</li>
   <pre>
let list = [1 .. 10 ] |> Seq.filter (fun x -> x % 2 <> 0)
                      |> Seq.map (fun x -> x * x)
                      |> Seq.sum                           // 165
   </pre>
</ul>
<li>Composition</li>
<ul>
   <li>Calls two functions in a sequence</li>
   <li>Returns a function instead of immediately invoking the sequence</li>
   <li><code>>></code> and <code><<</code> are the symbols for function composition</li>
   <pre>
let composed = Seq.filter (fun x -> x % 2 <> 0)
               >> Seq.map (fun x -> x * x)
               >> Seq.sum
composed [1 .. 10]                                         // 165
   </pre>
</ul>
<li>Piping and function compositions are very similar</li>
<li>The main difference is whether you want the function declaration to be explicit (piping) or implicit and reusable (function composition)</li>
<li>These are equivalent:</li>
<pre>
foo (fun x -> x |> bar |> baz)     // Explicit piping
foo (bar >> baz)                   // Function composition
</pre>
<li>Currying</li>
<ul>
   <li>Applies arguments to functions to create new functions</li>
   <li>Functions taking more than one argument are automatically curried by the compiler</li>
   <pre>
let printTwo a b = printfn "%A and %A" a b      // Uncurried (int -> unit)

let printTwoCurried a =                         // Curried   (int -> int -> unit)
   let printTwoSecond b =
      printfn "%A and %A" a b
   printTwoSecond
   </pre>
   <li>Currying also allows for the partial application of functions</li>
<pre>
let filterEvens = List.filter (fun x -> x % 2 = 0)
filterEvens [ 1 .. 5 ]                               // [2;4]
</pre>
   <li>.NET base class library functions are often re-written in wrappers to better match the partial function application form</li>
<pre>
let replace oldStr newStr (s:String) = s.Replace(oldValue = oldStr, newValue = newStr)   // Input string is now the last parameter
let result =                                                                             // "452"
   "CPS"
   |> replace "CPS" "452"
</pre>
</ul>
</ul>

<h2 id="acp"><hr align="left" width="40%"/>
Asynchronous, Concurrent, and Parallel Programming
<hr align="left" width="40%"/></h2>
<ul>
<li>Asynchronous Workflows</li>
<ul>
   <li>Built in asynchronous workflows make writing async code easier</li>
   <li>Workflows are objects that encapsulate a task and provide useful operations to manage them</li>
   <li>Asynchronous (library) workflow example:</li>
   <pre>
open System
let timerWithAsync = 
   let timer = new System.Timers.Timer(2000)
   let timerEvent = Async.AwaitEvent (timer.Elapsed) |> Async.Ignore       // Create async workflow and ignore its output

   timer.Start()                                                           // Start async work

   // Do some other computations

   Async.RunSynchronously timerEvent                                       // Block until async event completed
   </pre>
   <li>Manually created nested workflows:</li>
   <pre>
let otherWorkflow = async {                                // Expressions in async{} can be executed in the background
   do! Async.Sleep 2000
   }
let nestedWorkflow  = async {
   let! childWorkflow = Async.StartChild otherWorkflow     // Start

   do! Async.Sleep 100                                     // Do some work

   let! result = childWorkflow                             // Wait for the child
   }
Async.RunSynchronously nestedWorkflow  
   </pre>
   <li>The operators followed by bang (<code>let!</code>, <code>do!</code>, etc) are synonymous to calling <code>await</code> in most other languages</li>
   <li>Asynchronous workflows can also be cancelled manually</li>
   <pre>
open System
open System.Threading
let cancellationSource = new CancellationTokenSource()        // Creates cancellation soruce
Async.Start (testWorkflow, cancellationSource.Token)           // Attach the token to the workflow
cancellationSource.Cancel()                                   // Cancel the workflow
   </pre>
   <li>This is useful for error handling and is much easier than trying to keep track of flags inside workflows to signal a stop</li>
   <li>Any nested async call will check the token automatically</li>
   <li>Tasks can also be run in parallel by using <code>Async.Parallel</code></li>
</ul>
<li>Actor Model of Concurrency</li>
<ul>
   <li>Built in agent class called <code>MailboxProcessor</code></li>
   <li>Similar to Erlang agents, but they do not work across process boundaries</li>
   <pre>
let agent = MailboxProcessor.Start(fun inbox-> 
   let rec messageLoop() = async {
      let! msg = inbox.Receive()                        // Read a message
      printfn "Message is: %s" msg
      return! messageLoop()                             // Infinite loop
      }
   messageLoop() 
   )
agent.Post "CPS"
agent.Post "452"
   </pre>
   <li>Here is a simple counter agent example:</li>
   <pre>
type MessageBasedCounter () = 
   static let updateState (count,sum) msg =                
      let newSum = sum + msg
      let newCount = count + 1
      printfn "Count is: %i. Sum is: %i" newCount newSum 
      let rand = new Random()
      let ms = rand.Next(1,10)
      Thread.Sleep ms                                 // Emulate a short delay
      (newCount,newSum)

   static let agent = MailboxProcessor.Start(fun inbox -> 
      let rec messageLoop oldState = async{
         let! msg = inbox.Receive()                         // Read a message
         let newState = updateState oldState msg
         return! messageLoop newState                       // Infinite loop
         }
      messageLoop (0,0)                                     // Start the loop
      )

   static member Add x = agent.Post x                       // Static keyword means an instance of this type is not required to call this function

let makeTask funct id = async {
   printfn "Task %i created" id
   funct id
   }
[1..5]
   |> List.map (fun x -> makeTask MessageBasedCounter.Add x)
   |> Async.Parallel
   |> Async.RunSynchronously
   |> ignore
   </pre>
</ul>
</ul>

<h2 id="misc"><hr align="left" width="40%"/>
Miscellaneous
<hr align="left" width="40%"/></h2>
<ul>
<li>Lazy Evaluation</li>
<ul>
   <li>F# uses eager evaluation by default, but lazy evaluation can be invoked</li>
   <pre>
let x = 100
let result = lazy (x + 10)         // lazy freezes the expression and Force evaluates it
printfn "%i" (result.Force())      // 110
   </pre>
   <li>The <code>seq</code> type is also lazily evaluated</li>
   <li>A sequence can be any normal <code>IEnumerable</code> collection</li>
   <pre>
let seq1 = seq { for x in 1 .. 10 do yield x * x }   // seq [1; 4; 9; 16; ...]
let seq2 = seq { for x in 1 .. 10 -> x * x }         // equivalent
   </pre>
   <li>The <code>yield</code> and <code>yield!</code> keywords create subsequences</li>
   <li><code>yield</code> creates nested subsequences i.e. <code>seq{seq{...{seq{'T}</code></li>
   <li><code>yield!</code> creates a "flattened" subsequence i.e. <code>seq{'T}</code></li>
</ul>
<li>Continuations</li>
<ul>
   <li>Since passing functions in F# is so simple, continuations are a natural extension of the language</li>
   <pre>
let divideWithContinuation breakCase successCase x y =
   if (y = 0)
   then breakCase()
   else successCase (x / y)

let zeroCase () = printfn "broke out"
let regularCase x = printfn "%A" x
let good = divideWithContinuation zeroCase regularCase 6 3   // 2
let bad = divideWithContinuation zeroCase regularCase 6 0    // "broke out"
   </pre>
   <li>This also allows for Continuation Passing Style</li>
   <pre>
let x = 1 in
   let y = 2 in
      let z = x + y in
         z

1 |> (fun x ->              // This is the equivalent CPS transformation
   2 |> (fun y ->
      x + y |> (fun z ->
         z)))
   </pre>
</ul>
<li>Closures</li>
<ul>
   <li>While most F# uses will be with the traditional object-field approach to encapsulate state, closures are still possible</li>
   <pre>
let simpleClosure = 
  let scope = "old scope" 
  let enclose() = 
      sprintf "%s" scope 
  let scope = "new scope" 
  sprintf "%s --- %s" scope (enclose())

printfn "%A" simpleClosure                  // "new scope --- old scope"
   </pre>
</ul>
</ul>

<h2><hr align="left" width="40%"/>
Exercises
<hr align="left" width="40%"/></h2>
<ol>

<li>
<b>Partial Application/Piping</b> (10 points)
</li>

<li>
<b>Sequences/Types</b> (10 points)
<br/>
Define a generic binary tree type and use <code>yield</code>/<code>yield!</code> to create a single sequence representing the inorder traversal of the tree.
<br/>
Then print the first and last element of the traversal.
<br>
Test input/output:
<pre>
let tree1 = Tree(6, Tree(2, Leaf(1), Leaf(3)), Leaf(9))
let seq1 = inorder tree1
printfn "%A" seq1
let first = Seq.head seq1
let last = Seq.last seq1
printfn "First element: %A" first                         // 1
printfn "Last element: %A" last                           // 9

let tree2 = Tree(10, Tree(4, Leaf(2), Leaf(5)), Tree(15, Tree(13, Leaf(12), Leaf(14)), Leaf(16)))
let trav2 = inorder tree2
let first2 = Seq.head trav2
let last2 = Seq.last trav2
printfn "First element: %A" first2                         // 2
printfn "Last element: %A" last2                           // 16
</pre>
</li>

<li>
<b>Actor Model of Concurrency</b> (10 points)
</li>
</ol>

<p><hr align="left" width="40%"/>A GitHub repository containing code examples of the topics covered above (and more) can be found 
<a href="https://github.com/BerkshireT/FSharpNotes" target="blank"/>here</a>
</p>
<p><a href="#top">Top</a></p>

<h2><hr align="left" width="40%"/>References</h2>

<ul>
<table>

<tr>
<td>
"<a href="https://en.wikipedia.org/wiki/F_Sharp_(programming_language)">F sharp (programming language)</a>."
(2019). <i>Wikipedia: The Free Encyclopedia</i>. Wikimedia Foundation, Inc.
</td>
</tr>

<tr>
<td>
"<a href="https://docs.microsoft.com/en-us/dotnet/fsharp/">F# guide</a>."
(2018). <i>Microsoft</i>. Microsoft.
</td>
</tr>

<tr>
<td>
“<a href="https://fsharp.org/">F# software foundation</a>.”
(2019). <i>F# Software Foundation</i>, F# Software Foundation.
</td>
</tr>

<tr>
<td>Syme, Don, et al.
"<a href="https://fsharp.org/specs/language-spec/4.1/FSharpSpec-4.1-latest.pdf">The f# 4.1 language specification</a>."
(2016). <i>F# Software Foundation</i>.
</td>
</tr>

<tr>
<td>W., Scott,
"<a href="https://fsharpforfunandprofit.com/posts/key-concepts/">Four key concepts</a>."
(2012). <i>fsharpforfunandprofit</i>.
</td>
</tr>

<!--
<tr>
<td valign="top">[EMLP]</td>
<td>J.D. Ullman.
<a href="http://infolab.stanford.edu/~ullman/emlp.html"><i>Elements
of ML Programming</i></a>.
-->
<!--
<i>Elements of ML Programming</i>.
Prentice Hall, Upper Saddle River, NJ, Second edition, 1997.</td>
</tr>
-->

</table>
</ul>

<hr align="center" width="80%" size="10"/>
<a href="index.html"><img src="http://academic.udayton.edu/SaverioPerugini/images/rh.jpg" alt="Return Home" border="0"/></a>
</td>
</tr>
</table>

</body>
</html>